{"repository_name":"markov","body":"# â›“ Markov\n\nA Crystal library for building Markov Chains and running Markov Processes.\n\n[![Build Status](https://travis-ci.org/mccallofthewild/markov.svg?branch=master)](https://travis-ci.org/mccallofthewild/markov) [![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](https://mccallofthewild.github.io/markov/) [![GitHub release](https://img.shields.io/github/release/mccallofthewild/markov.svg)](https://github.com/mccallofthewild/markov/releases)\n\n### _What is a Markov Chain?_\n\nA Markov Chain is essentially a mechanism for guessing probable future events based on a sample of past events.\nFor a great explanation, watch [this Khan Academy video](https://www.khanacademy.org/computing/computer-science/informationtheory/moderninfotheory/v/markov_chains).\n\n### Visit the [API Documentation](https://mccallofthewild.github.io/markov/) for a more in-depth look at the library's functionality.\n\n## Installation\n\nAdd this to your application's `shard.yml`:\n\n```yaml\ndependencies:\n  markov:\n    github: mccallofthewild/markov\n```\nIn your terminal, install Crystal dependencies with:\n```bash\n$ shards install\n```\nor \n```bash\n$ crystal deps\n```\n\n## Usage\nBegin by requiring the `Markov` module:\n```crystal\nrequire \"markov\"\n```\n### Basic -- Hello Markov\nA classic Markov text generator. This example will work well for small (array-sized) data sets.\n\nNOTE: `Markov::Chain` is a generic type which contains, receives and generates elements of `LinkType`.\n\nWe'll start with the sample text:\n```crystal \nexample_string = \"how much wood would a woodchuck chuck if a woodchuck could chuck wood\"\n```\nThere are several `Markov::Chain` constructors to choose from. The simplest one takes in a `LinkType` array of elements as `sample` and a `seed` of `LinkType`. `seed` is the element in `sample` you want to start the chain with. If not provided, a random element will be chosen.\n```crystal\nexample_arr = example_string.split(\" \") #=> [\"how\",\"much\",\"wood\",\"would\",\"a\",\"woodchuck\",\"chuck\",\"if\",\"a\",\"woodchuck\",\"could\",\"chuck\",\"wood\"]\nseed = example_arr[0] #=> \"how\"\n\nexample_chain = Markov::Chain(String).new sample: example_arr, seed: seed\n```\nFinally, we'll generate a probable sequence of elements with the `Markov::Chain#generate` method:\n```crystal\nputs example_chain.generate(10)\n```\nOutput:\n```bash\n[\"much\", \"wood\", \"would\", \"a\", \"woodchuck\", \"could\", \"chuck\", \"if\", \"a\", \"woodchuck\"]\n```\nThat's it! \n\nIf we wanted to get the elements one at a time, we could use the `Markov::Chain#next` method instead:\n```crystal\nputs example_chain.next #=> \"much\"\nputs example_chain.next #=> \"wood\"\nputs example_chain.next #=> \"would\"\n```\n\n### Advanced \nThis implementation was built for larger data sets, with asynchronous input in mind.\n\nIn this example, we will create a `Markov::Chain` which can generate realistic movie titles.\n\nTo begin, we instantiate a `Markov::TransitionTable`. A `TransitionTable` is a mechanism for training and implementing Markov processes.\n\n```crystal \nexample_table = Markov::TransitionTable(String).new\n```\n\n#### `Markov::TransitionTable#add`\nNow we'll add a movie title using the `Markov::TransitionTable#add` method:\n\n```crystal\nmovie_one = %w(the great gatsby) # shortcut syntax for [\"the\",\"great\",\"gatsby\"]\n\nmovie_one.each do |word|\n  example_table.add(word)\nend\n```\n`Markov::TransitionTable#add` adds elements one at a time. At a deeper level, it's adding each new word to the previous word's [Transition Matrix](https://en.wikipedia.org/wiki/Stochastic_matrix) (`Markov::TransitionMatrix`).\n\n#### `Markov::TransitionTable#fill`\nFor syntactic sugar, if we have an array of elements, we can avoid looping through and `#add`-ing them by using the `Markov::TransitionTable#fill` method instead:\n\n```crystal\nmovie_one = %w(the great gatsby) # shortcut syntax for [\"the\",\"great\",\"gatsby\"]\n\nexample_table.fill table_with: movie_one\n```\n\n#### `Markov::TransitionTable#reset`\nA problem arises at this point:\n```crystal\nmovie_two = %w(great expectations)\nexample_table.fill table_with: movie_two\n```\nThe above code sequentially adds each word to the `TransitionTable`. But _The Great Gatsby_ and _Great Expectations_ are two separate movie titles; the \"Great\" at the beginning of _Great Expectations_ is not a probable transition from the \"Gatsby\" at the end of _The Great Gatsby_.\n\nTo solve this, use `Markov::TransitionTable#reset`. `#reset` clears the `TransitionTable`'s last added key, allowing us to separate titles like so:\n\n```crystal \nmovie_one = %w(the great gatsby)\nexample_table.fill table_with: movie_one\n\nexample_table.reset\nmovie_two = %w(great expectations)\nexample_table.fill table_with: movie_two\n\nexample_table.reset\nmovie_three = %w(the great escape)\nexample_table.fill table_with: movie_three\n```\n\n#### Implementing the `TransitionTable` with a `Markov::Chain`\nFinally, we can put the `TransitionTable` to use by passing it to a `Markov::Chain` constructor as `transition_table`:\n\n```crystal\nexample_chain = Markov::Chain(String).new transition_table: example_table, seed: \"great\"\n```\n\n#### Handling Dead Ends\nWith small and/or unique data sets, Markov chains are fallible to reaching dead ends. That is, they can often reach a point where there is nothing to transition to.\n\nWhen this happens in the `Markov` module, `Markov::Exceptions::EmptyTransitionMatrixException` is raised.\n\nFor example:\n\n```crystal\ndead_end_array = %w(some say the world will end in fire)\ndead_end_chain = Markov::Chain(String).new sample: dead_end_array, seed: \"fire\"\n# nothing comes after \"fire\", so the chain is at a dead end.\ndead_end_chain.next # raises `EmptyTransitionMatrixException`\n```\n\nTo prevent this, use the `Markov::Chain#on_dead_end` exception handler. \n\nThis method takes in a callback block with arguments of: the `Markov::Chain`'s `@transition_table`, the `Markov::Chain` instance, and the `EmptyTransitionMatrixException` raised.\n\nThe block's return value of `LinkType` fills in as the next item in the chain.\n\n```crystal\ndead_end_array = %w(some say the world will end in fire)\ndead_end_chain = Markov::Chain(String).new sample: dead_end_array, seed: \"fire\"\n\ndead_end_chain.on_dead_end do |transition_table, chain, exception|\n  \"some\"\nend\n\ndead_end_chain.next #=> \"some\"\ndead_end_chain.next #=> \"say\"\ndead_end_chain.next #=> \"the\"\n```\n\n## Contributing\n\n1. Fork it ( https://github.com/mccallofthewild/markov/fork )\n2. Create your feature branch (git checkout -b my-new-feature)\n3. Commit your changes (git commit -am 'Add some feature')\n4. Push to the branch (git push origin my-new-feature)\n5. Create a new Pull Request\n\n## Contributors\n\n- [McCall Alexander](https://github.com/mccallofthewild) mccallofthewild - creator, maintainer\n","program":{"html_id":"markov/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"markov","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"markov/Markov","path":"Markov.html","kind":"module","full_name":"Markov","name":"Markov","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":"Module `Markov` contains the means for creating Markov Chains and executing Markov Processes.","summary":"<p>Module <code><a href=\"Markov.html\">Markov</a></code> contains the means for creating Markov Chains and executing Markov Processes.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"markov/Markov/Chain","path":"Markov/Chain.html","kind":"class","full_name":"Markov::Chain(LinkType)","name":"Chain","abstract":false,"superclass":{"html_id":"markov/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"markov/JSON/Serializable","kind":"module","full_name":"JSON::Serializable","name":"Serializable"},{"html_id":"markov/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"markov/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[{"html_id":"markov/JSON/Serializable","kind":"module","full_name":"JSON::Serializable","name":"Serializable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"markov/Markov","kind":"module","full_name":"Markov","name":"Markov"},"doc":"A `Chain` is a vehicle for generating probable sequences of type `LinkType`","summary":"<p>A <code><a href=\"../Markov/Chain.html\">Chain</a></code> is a vehicle for generating probable sequences of type <code>LinkType</code></p>","class_methods":[],"constructors":[{"id":"new(transition_table:TransitionTable(LinkType),seed:LinkType?=nil)-class-method","html_id":"new(transition_table:TransitionTable(LinkType),seed:LinkType?=nil)-class-method","name":"new","doc":"For larger processes, you'll want to externally train a `TransitionTable` then\npass it in as an argument.\nIf `seed` is not provided, it will default to a random item chosen with `TransitionTable#random_key`","summary":"<p>For larger processes, you'll want to externally train a <code><a href=\"../Markov/TransitionTable.html\">TransitionTable</a></code> then pass it in as an argument.</p>","abstract":false,"args":[{"name":"transition_table","doc":null,"default_value":"","external_name":"transition_table","restriction":"TransitionTable(LinkType)"},{"name":"seed","doc":null,"default_value":"nil","external_name":"seed","restriction":"LinkType | Nil"}],"args_string":"(transition_table : TransitionTable(LinkType), seed : LinkType? = <span class=\"n\">nil</span>)","args_html":"(transition_table : <a href=\"../Markov/TransitionTable.html\">TransitionTable</a>(LinkType), seed : LinkType? = <span class=\"n\">nil</span>)","location":{"filename":"src/markov/chain.cr","line_number":30,"url":null},"def":{"name":"new","args":[{"name":"transition_table","doc":null,"default_value":"","external_name":"transition_table","restriction":"TransitionTable(LinkType)"},{"name":"seed","doc":null,"default_value":"nil","external_name":"seed","restriction":"LinkType | Nil"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Chain(LinkType).allocate\n_.initialize(transition_table, seed)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"id":"new(sample:Array(LinkType),seed:LinkType=(sample.sample(1)).first)-class-method","html_id":"new(sample:Array(LinkType),seed:LinkType=(sample.sample(1)).first)-class-method","name":"new","doc":"\nIf you have a small (`Array`-sized) data set, you can pass it as `sample`\nand a `TransitionTable` will be constructed for you with the sample data.\n\n`seed` should be the element in `sample` which you would like to begin the sequence.\nIf no `seed` is provided, a random element will be selected from `sample`.","summary":"<p>If you have a small (<code>Array</code>-sized) data set, you can pass it as <code>sample</code> and a <code><a href=\"../Markov/TransitionTable.html\">TransitionTable</a></code> will be constructed for you with the sample data.</p>","abstract":false,"args":[{"name":"sample","doc":null,"default_value":"","external_name":"sample","restriction":"Array(LinkType)"},{"name":"seed","doc":null,"default_value":"(sample.sample(1)).first","external_name":"seed","restriction":"LinkType"}],"args_string":"(sample : Array(LinkType), seed : LinkType = (sample.sample(<span class=\"n\">1</span>)).first)","args_html":"(sample : Array(LinkType), seed : LinkType = (sample.sample(<span class=\"n\">1</span>)).first)","location":{"filename":"src/markov/chain.cr","line_number":72,"url":null},"def":{"name":"new","args":[{"name":"sample","doc":null,"default_value":"","external_name":"sample","restriction":"Array(LinkType)"},{"name":"seed","doc":null,"default_value":"(sample.sample(1)).first","external_name":"seed","restriction":"LinkType"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Chain(LinkType).allocate\n_.initialize(sample, seed)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"id":"new(pull:JSON::PullParser)-class-method","html_id":"new(pull:JSON::PullParser)-class-method","name":"new","doc":"Makes it possible to use `#to_json` and `#from_json` (see Crystal docs)","summary":"<p>Makes it possible to use <code>#to_json</code> and <code>#from_json</code> (see Crystal docs)</p>","abstract":false,"args":[{"name":"pull","doc":null,"default_value":"","external_name":"pull","restriction":"JSON::PullParser"}],"args_string":"(pull : JSON::PullParser)","args_html":"(pull : JSON::PullParser)","location":{"filename":"src/markov/chain.cr","line_number":50,"url":null},"def":{"name":"new","args":[{"name":"pull","doc":null,"default_value":"","external_name":"pull","restriction":"JSON::PullParser"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Chain(LinkType).allocate\n_.initialize(pull)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"generate(count:Int32)-instance-method","html_id":"generate(count:Int32)-instance-method","name":"generate","doc":"Generates a probable, sequential `Array` of `LinkType` elements of `count` length","summary":"<p>Generates a probable, sequential <code>Array</code> of <code>LinkType</code> elements of <code>count</code> length</p>","abstract":false,"args":[{"name":"count","doc":null,"default_value":"","external_name":"count","restriction":"Int32"}],"args_string":"(count : Int32)","args_html":"(count : Int32)","location":{"filename":"src/markov/chain.cr","line_number":98,"url":null},"def":{"name":"generate","args":[{"name":"count","doc":null,"default_value":"","external_name":"count","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"i = 0\ntemp_generated = [] of LinkType\nwhile i < count\n  el = self.next\n  temp_generated.push(el)\n  i = i + 1\nend\n@generated.concat(temp_generated)\ntemp_generated\n"}},{"id":"generated:Array(LinkType)-instance-method","html_id":"generated:Array(LinkType)-instance-method","name":"generated","doc":"Returns an ordered `Array(LinkType)` of all `LinkType` elements generated","summary":"<p>Returns an ordered <code>Array(LinkType)</code> of all <code>LinkType</code> elements generated</p>","abstract":false,"args":[],"args_string":" : Array(LinkType)","args_html":" : Array(LinkType)","location":{"filename":"src/markov/chain.cr","line_number":11,"url":null},"def":{"name":"generated","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(LinkType)","visibility":"Public","body":"@generated"}},{"id":"next:LinkType-instance-method","html_id":"next:LinkType-instance-method","name":"next","doc":"Generates the next probable `LinkType` element","summary":"<p>Generates the next probable <code>LinkType</code> element</p>","abstract":false,"args":[],"args_string":" : LinkType","args_html":" : LinkType","location":{"filename":"src/markov/chain.cr","line_number":133,"url":null},"def":{"name":"next","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"LinkType","visibility":"Public","body":"seed = @seed\nbegin\n  seed = @transition_table.probable(after: @seed)\nrescue ex : Markov::Exceptions::EmptyTransitionMatrixException\n  if @custom_dead_end_handler\n    seed = @dead_end_handler.call(@transition_table, self, ex)\n  else\n    raise(ex)\n  end\nend\nvalidate_seed(seed: seed, rule: \"`@seed` must be an existing key in `@transition_table`\")\n@seed = seed\n@generated.push(@seed)\n@seed\n"}},{"id":"on_dead_end(&block:Proc(TransitionTable(LinkType),Chain(LinkType),Exception,LinkType)):Proc(TransitionTable(LinkType),Chain(LinkType),Exception,LinkType)-instance-method","html_id":"on_dead_end(&block:Proc(TransitionTable(LinkType),Chain(LinkType),Exception,LinkType)):Proc(TransitionTable(LinkType),Chain(LinkType),Exception,LinkType)-instance-method","name":"on_dead_end","doc":"Sets an exception handler for `EmptyTransitionMatrixException` when `Chain` instance reaches a dead end\nwhile using `Chain#generate` or `Chain#next`. Returned value is inserted as the next probable element.\n\nUsage:\n\n```\nc = Markov::Chain(String).new sample: [\"Koala\", \"Kangaroo\"] of String, seed: \"Kangaroo\"\nc.on_dead_end do |transition_table, chain, exception|\n  \"Koala\"\nend\nc.next # => \"Koala\"\nc.next # => \"Kangaroo\"\nc.next # => \"Koala\"\n```","summary":"<p>Sets an exception handler for <code>EmptyTransitionMatrixException</code> when <code><a href=\"../Markov/Chain.html\">Chain</a></code> instance reaches a dead end while using <code><a href=\"../Markov/Chain.html#generate(count:Int32)-instance-method\">Chain#generate</a></code> or <code><a href=\"../Markov/Chain.html#next:LinkType-instance-method\">Chain#next</a></code>.</p>","abstract":false,"args":[],"args_string":"(&block : Proc(TransitionTable(LinkType), Chain(LinkType), Exception, LinkType)) : Proc(TransitionTable(LinkType), Chain(LinkType), Exception, LinkType)","args_html":"(&block : Proc(<a href=\"../Markov/TransitionTable.html\">TransitionTable</a>(LinkType), <a href=\"../Markov/Chain.html\">Chain</a>(LinkType), Exception, LinkType)) : Proc(<a href=\"../Markov/TransitionTable.html\">TransitionTable</a>(LinkType), <a href=\"../Markov/Chain.html\">Chain</a>(LinkType), Exception, LinkType)","location":{"filename":"src/markov/chain.cr","line_number":126,"url":null},"def":{"name":"on_dead_end","args":[],"double_splat":null,"splat_index":null,"yields":0,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"Proc(TransitionTable(LinkType), Chain(LinkType), Exception, LinkType)"},"return_type":"Proc(TransitionTable(LinkType), Chain(LinkType), Exception, LinkType)","visibility":"Public","body":"@dead_end_handler = block\n@custom_dead_end_handler = true\nblock\n"}},{"id":"seed:LinkType-instance-method","html_id":"seed:LinkType-instance-method","name":"seed","doc":"Returns `seed` element.","summary":"<p>Returns <code><a href=\"../Markov/Chain.html#seed:LinkType-instance-method\">#seed</a></code> element.</p>","abstract":false,"args":[],"args_string":" : LinkType","args_html":" : LinkType","location":{"filename":"src/markov/chain.cr","line_number":17,"url":null},"def":{"name":"seed","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"LinkType","visibility":"Public","body":"@seed"}},{"id":"transition_table:TransitionTable(LinkType)-instance-method","html_id":"transition_table:TransitionTable(LinkType)-instance-method","name":"transition_table","doc":"Returns the trained instance of `TransitionTable`","summary":"<p>Returns the trained instance of <code><a href=\"../Markov/TransitionTable.html\">TransitionTable</a></code></p>","abstract":false,"args":[],"args_string":" : TransitionTable(LinkType)","args_html":" : <a href=\"../Markov/TransitionTable.html\">TransitionTable</a>(LinkType)","location":{"filename":"src/markov/chain.cr","line_number":14,"url":null},"def":{"name":"transition_table","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"TransitionTable(LinkType)","visibility":"Public","body":"@transition_table"}}],"macros":[],"types":[]},{"html_id":"markov/Markov/Exceptions","path":"Markov/Exceptions.html","kind":"module","full_name":"Markov::Exceptions","name":"Exceptions","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"markov/Markov","kind":"module","full_name":"Markov","name":"Markov"},"doc":"Holds all custom exceptions in the `Markov` module.","summary":"<p>Holds all custom exceptions in the <code><a href=\"../Markov.html\">Markov</a></code> module.</p>","class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"markov/Markov/Exceptions/EmptyTransitionMatrixException","path":"Markov/Exceptions/EmptyTransitionMatrixException.html","kind":"class","full_name":"Markov::Exceptions::EmptyTransitionMatrixException","name":"EmptyTransitionMatrixException","abstract":false,"superclass":{"html_id":"markov/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"markov/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"markov/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"markov/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"markov/Markov/Exceptions","kind":"module","full_name":"Markov::Exceptions","name":"Exceptions"},"doc":"Thrown when a method cannot execute due to a `TransitionMatrix` being empty.","summary":"<p>Thrown when a method cannot execute due to a <code><a href=\"../../Markov/TransitionMatrix.html\">TransitionMatrix</a></code> being empty.</p>","class_methods":[],"constructors":[{"id":"new(method:String,message:String=&quot;&quot;)-class-method","html_id":"new(method:String,message:String=&quot;&quot;)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"method","doc":null,"default_value":"","external_name":"method","restriction":"String"},{"name":"message","doc":null,"default_value":"\"\"","external_name":"message","restriction":"String"}],"args_string":"(method : String, message : String = <span class=\"s\">&quot;&quot;</span>)","args_html":"(method : String, message : String = <span class=\"s\">&quot;&quot;</span>)","location":{"filename":"src/markov/exceptions.cr","line_number":5,"url":null},"def":{"name":"new","args":[{"name":"method","doc":null,"default_value":"","external_name":"method","restriction":"String"},{"name":"message","doc":null,"default_value":"\"\"","external_name":"message","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(method, message)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"markov/Markov/Exceptions/EmptyTransitionTableException","path":"Markov/Exceptions/EmptyTransitionTableException.html","kind":"class","full_name":"Markov::Exceptions::EmptyTransitionTableException","name":"EmptyTransitionTableException","abstract":false,"superclass":{"html_id":"markov/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"markov/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"markov/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"markov/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"markov/Markov/Exceptions","kind":"module","full_name":"Markov::Exceptions","name":"Exceptions"},"doc":"Thrown when a method cannot execute due to a `TransitionTable` being empty.","summary":"<p>Thrown when a method cannot execute due to a <code><a href=\"../../Markov/TransitionTable.html\">TransitionTable</a></code> being empty.</p>","class_methods":[],"constructors":[{"id":"new(method:String,message:String=&quot;&quot;)-class-method","html_id":"new(method:String,message:String=&quot;&quot;)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"method","doc":null,"default_value":"","external_name":"method","restriction":"String"},{"name":"message","doc":null,"default_value":"\"\"","external_name":"message","restriction":"String"}],"args_string":"(method : String, message : String = <span class=\"s\">&quot;&quot;</span>)","args_html":"(method : String, message : String = <span class=\"s\">&quot;&quot;</span>)","location":{"filename":"src/markov/exceptions.cr","line_number":12,"url":null},"def":{"name":"new","args":[{"name":"method","doc":null,"default_value":"","external_name":"method","restriction":"String"},{"name":"message","doc":null,"default_value":"\"\"","external_name":"message","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(method, message)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]},{"html_id":"markov/Markov/Exceptions/InvalidSeedException","path":"Markov/Exceptions/InvalidSeedException.html","kind":"class","full_name":"Markov::Exceptions::InvalidSeedException","name":"InvalidSeedException","abstract":false,"superclass":{"html_id":"markov/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"markov/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"markov/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"markov/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"markov/Markov/Exceptions","kind":"module","full_name":"Markov::Exceptions","name":"Exceptions"},"doc":"Thrown when a method cannot execute due to an invalid `seed`.","summary":"<p>Thrown when a method cannot execute due to an invalid <code>seed</code>.</p>","class_methods":[],"constructors":[{"id":"new(message:String=&quot;&quot;)-class-method","html_id":"new(message:String=&quot;&quot;)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"message","doc":null,"default_value":"\"\"","external_name":"message","restriction":"String"}],"args_string":"(message : String = <span class=\"s\">&quot;&quot;</span>)","args_html":"(message : String = <span class=\"s\">&quot;&quot;</span>)","location":{"filename":"src/markov/exceptions.cr","line_number":19,"url":null},"def":{"name":"new","args":[{"name":"message","doc":null,"default_value":"\"\"","external_name":"message","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(message)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"markov/Markov/TransitionMatrix","path":"Markov/TransitionMatrix.html","kind":"class","full_name":"Markov::TransitionMatrix(LinkType)","name":"TransitionMatrix","abstract":false,"superclass":{"html_id":"markov/Hash","kind":"class","full_name":"Hash","name":"Hash"},"ancestors":[{"html_id":"markov/Hash","kind":"class","full_name":"Hash","name":"Hash"},{"html_id":"markov/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"markov/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"markov/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"markov/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"markov/Markov","kind":"module","full_name":"Markov","name":"Markov"},"doc":"A `TransitionMatrix` is an object for storing and selecting transitions in a `Markov::Chain`.\n\nSee [https://en.wikipedia.org/wiki/Stochastic_matrix](https://en.wikipedia.org/wiki/Stochastic_matrix)","summary":"<p>A <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code> is an object for storing and selecting transitions in a <code><a href=\"../Markov/Chain.html\">Markov::Chain</a></code>.</p>","class_methods":[],"constructors":[{"id":"new(pull:JSON::PullParser)-class-method","html_id":"new(pull:JSON::PullParser)-class-method","name":"new","doc":"Makes it possible to use `#to_json` and `#from_json` (see Crystal docs)","summary":"<p>Makes it possible to use <code>#to_json</code> and <code>#from_json</code> (see Crystal docs)</p>","abstract":false,"args":[{"name":"pull","doc":null,"default_value":"","external_name":"pull","restriction":"JSON::PullParser"}],"args_string":"(pull : JSON::PullParser)","args_html":"(pull : JSON::PullParser)","location":{"filename":"src/markov/transition_matrix.cr","line_number":16,"url":null},"def":{"name":"new","args":[{"name":"pull","doc":null,"default_value":"","external_name":"pull","restriction":"JSON::PullParser"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = TransitionMatrix(LinkType).allocate\n_.initialize(pull)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":"Creates a new empty `TransitionMatrix`.","summary":"<p>Creates a new empty <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code>.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/markov/transition_matrix.cr","line_number":11,"url":null},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = TransitionMatrix(LinkType).allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"add(link:LinkType)-instance-method","html_id":"add(link:LinkType)-instance-method","name":"add","doc":"Adds item to `TransitionMatrix`","summary":"<p>Adds item to <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code></p>","abstract":false,"args":[{"name":"link","doc":null,"default_value":"","external_name":"link","restriction":"LinkType"}],"args_string":"(link : LinkType)","args_html":"(link : LinkType)","location":{"filename":"src/markov/transition_matrix.cr","line_number":32,"url":null},"def":{"name":"add","args":[{"name":"link","doc":null,"default_value":"","external_name":"link","restriction":"LinkType"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"count : Int32\nif self.has_key?(link)\n  count = self[link] + 1\nelse\n  count = 1.to_i32\nend\nself[link] = count\n"}},{"id":"probabilities:Hash(LinkType,Float32)-instance-method","html_id":"probabilities:Hash(LinkType,Float32)-instance-method","name":"probabilities","doc":"Returns decimal probability of each transition in the matrix","summary":"<p>Returns decimal probability of each transition in the matrix</p>","abstract":false,"args":[],"args_string":" : Hash(LinkType, Float32)","args_html":" : Hash(LinkType, Float32)","location":{"filename":"src/markov/transition_matrix.cr","line_number":43,"url":null},"def":{"name":"probabilities","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Hash(LinkType, Float32)","visibility":"Public","body":"probs = Hash(LinkType, Float32).new(default_value: 0.to_f32)\ntotal : Int32 = sum()\nself.each do |key, value|\n  probs[key] = value.to_f32 / sum.to_f32\nend\nprobs\n"}},{"id":"probable_transition:LinkType-instance-method","html_id":"probable_transition:LinkType-instance-method","name":"probable_transition","doc":"Chooses a random, probable transition from the transitions in the matrix.\nIf matrix is empty, will throw `Markov::Exceptions::EmptyTransitionMatrixException`","summary":"<p>Chooses a random, probable transition from the transitions in the matrix.</p>","abstract":false,"args":[],"args_string":" : LinkType","args_html":" : LinkType","location":{"filename":"src/markov/transition_matrix.cr","line_number":63,"url":null},"def":{"name":"probable_transition","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"LinkType","visibility":"Public","body":"if self.size == 0\n  raise(Markov::Exceptions::EmptyTransitionMatrixException.new(method: \"probable_transition\", message: \"No transitions availiable!\"))\nend\nprobable = nil\nsuccess_params = {} of LinkType => Range(Int32, Int32)\nlow : Int32 = 0\nhigh : Int32 = 0\ninitial_low = low\nself.each do |key, count|\n  low = high\n  high = low + count\n  success_params[key] = low...high\nend\nfinal_high = high\nexclusive_capturing_range = initial_low...final_high\nrandom_selection : Int32 = Random.rand(exclusive_capturing_range)\nsuccess_params.each do |key, capturing_range|\n  if capturing_range.includes?(random_selection)\n    probable = key\n  end\nend\nif !probable\n  raise(Markov::Exceptions::EmptyTransitionMatrixException.new(method: \"probable_transition\", message: \"Transition not found!\"))\nelse\n  return probable\nend\n"}},{"id":"sum:Int32-instance-method","html_id":"sum:Int32-instance-method","name":"sum","doc":"Returns sum of all values (occurrences) in the matrix","summary":"<p>Returns sum of all values (occurrences) in the matrix</p>","abstract":false,"args":[],"args_string":" : Int32","args_html":" : Int32","location":{"filename":"src/markov/transition_matrix.cr","line_number":53,"url":null},"def":{"name":"sum","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"total : Int32 = 0.to_i32\nself.each_value do |num|\n  total = total + num\nend\ntotal\n"}}],"macros":[],"types":[]},{"html_id":"markov/Markov/TransitionTable","path":"Markov/TransitionTable.html","kind":"class","full_name":"Markov::TransitionTable(LinkType)","name":"TransitionTable","abstract":false,"superclass":{"html_id":"markov/Hash","kind":"class","full_name":"Hash","name":"Hash"},"ancestors":[{"html_id":"markov/Hash","kind":"class","full_name":"Hash","name":"Hash"},{"html_id":"markov/Iterable","kind":"module","full_name":"Iterable","name":"Iterable"},{"html_id":"markov/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"markov/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"markov/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"markov","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"markov/Markov","kind":"module","full_name":"Markov","name":"Markov"},"doc":"A `TransitionTable` represents a mapping of keys to `TransitionMatrix`'s.","summary":"<p>A <code><a href=\"../Markov/TransitionTable.html\">TransitionTable</a></code> represents a mapping of keys to <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code>'s.</p>","class_methods":[],"constructors":[{"id":"new(pull:JSON::PullParser)-class-method","html_id":"new(pull:JSON::PullParser)-class-method","name":"new","doc":"Makes it possible to use `#to_json` and `#from_json` (see Crystal docs)","summary":"<p>Makes it possible to use <code>#to_json</code> and <code>#from_json</code> (see Crystal docs)</p>","abstract":false,"args":[{"name":"pull","doc":null,"default_value":"","external_name":"pull","restriction":"JSON::PullParser"}],"args_string":"(pull : JSON::PullParser)","args_html":"(pull : JSON::PullParser)","location":{"filename":"src/markov/transition_table.cr","line_number":14,"url":null},"def":{"name":"new","args":[{"name":"pull","doc":null,"default_value":"","external_name":"pull","restriction":"JSON::PullParser"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = TransitionTable(LinkType).allocate\n_.initialize(pull)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"id":"new-class-method","html_id":"new-class-method","name":"new","doc":"Creates a new empty `TransitionMatrix`.","summary":"<p>Creates a new empty <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code>.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/markov/transition_table.cr","line_number":9,"url":null},"def":{"name":"new","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = TransitionTable(LinkType).allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"add(key:LinkType)-instance-method","html_id":"add(key:LinkType)-instance-method","name":"add","doc":"Inserts `key` into last added `key`'s `TransitionMatrix`, if applicable,\nand creates new `TransitionMatrix` for `key` if not already there.","summary":"<p>Inserts <code>key</code> into last added <code>key</code>'s <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code>, if applicable, and creates new <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code> for <code>key</code> if not already there.</p>","abstract":false,"args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"LinkType"}],"args_string":"(key : LinkType)","args_html":"(key : LinkType)","location":{"filename":"src/markov/transition_table.cr","line_number":31,"url":null},"def":{"name":"add","args":[{"name":"key","doc":null,"default_value":"","external_name":"key","restriction":"LinkType"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if @last_added_key\n  last_matrix = self[@last_added_key]\n  last_matrix.add(key)\nend\nif !(self.has_key?(key))\n  self[key] = TransitionMatrix(LinkType).new\nend\n@last_added_key = key\n"}},{"id":"fill(table_withsample:Array(LinkType))-instance-method","html_id":"fill(table_withsample:Array(LinkType))-instance-method","name":"fill","doc":"Sequentially fills `TransitionTable` with values in given `Array` using `#add` method.\nJust a shortcut for looping through array and `#add`ing elements.\n```\nstring_array = %w(some say the world will end in fire)\ntt = Markov::TransitionTable(String).new\ntt.fill table_with: string_array\n```","summary":"<p>Sequentially fills <code><a href=\"../Markov/TransitionTable.html\">TransitionTable</a></code> with values in given <code>Array</code> using <code><a href=\"../Markov/TransitionTable.html#add(key:LinkType)-instance-method\">#add</a></code> method.</p>","abstract":false,"args":[{"name":"sample","doc":null,"default_value":"","external_name":"table_with","restriction":"Array(LinkType)"}],"args_string":"(table_with sample : Array(LinkType))","args_html":"(table_with sample : Array(LinkType))","location":{"filename":"src/markov/transition_table.cr","line_number":49,"url":null},"def":{"name":"fill","args":[{"name":"sample","doc":null,"default_value":"","external_name":"table_with","restriction":"Array(LinkType)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"sample.each do |key|\n  add(key)\nend"}},{"id":"probable(afterkey:LinkType):LinkType-instance-method","html_id":"probable(afterkey:LinkType):LinkType-instance-method","name":"probable","doc":"Returns probable transition from the `TransitionMatrix` associated with key provided.\nWill raise `EmptyTransitionMatrixException` if no probable transition is available.\n```\nstring_array = %w(some say the world will end in fire)\ntt = Markov::TransitionTable(String).new\ntt.fill table_with: string_array\n\ntt.probable? after: \"world\" # => \"will\"\ntt.probable? after: \"fire\"  # raises `EmptyTransitionMatrixException`\n```","summary":"<p>Returns probable transition from the <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code> associated with key provided.</p>","abstract":false,"args":[{"name":"key","doc":null,"default_value":"","external_name":"after","restriction":"LinkType"}],"args_string":"(after key : LinkType) : LinkType","args_html":"(after key : LinkType) : LinkType","location":{"filename":"src/markov/transition_table.cr","line_number":65,"url":null},"def":{"name":"probable","args":[{"name":"key","doc":null,"default_value":"","external_name":"after","restriction":"LinkType"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"LinkType","visibility":"Public","body":"self[key].probable_transition"}},{"id":"probable?(afterkey:LinkType):LinkType?-instance-method","html_id":"probable?(afterkey:LinkType):LinkType?-instance-method","name":"probable?","doc":"Returns probable transition from the `TransitionMatrix` associated with key provided.\nReturns `nil` if no probable transition is available.\n```\nstring_array = %w(some say the world will end in fire)\ntt = Markov::TransitionTable(String).new\ntt.fill table_with: string_array\n\ntt.probable? after: \"world\" # => \"will\"\ntt.probable? after: \"fire\"  # => nil\n```","summary":"<p>Returns probable transition from the <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code> associated with key provided.</p>","abstract":false,"args":[{"name":"key","doc":null,"default_value":"","external_name":"after","restriction":"LinkType"}],"args_string":"(after key : LinkType) : LinkType?","args_html":"(after key : LinkType) : LinkType?","location":{"filename":"src/markov/transition_table.cr","line_number":79,"url":null},"def":{"name":"probable?","args":[{"name":"key","doc":null,"default_value":"","external_name":"after","restriction":"LinkType"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"LinkType | Nil","visibility":"Public","body":"begin\n  return probable(key)\nrescue Markov::Exceptions::EmptyTransitionMatrixException\n  return nil\nend"}},{"id":"random_key:LinkType-instance-method","html_id":"random_key:LinkType-instance-method","name":"random_key","doc":"Returns random key.\nWill raise `EmptyTransitionTableException` if `TransitionTable` is empty.","summary":"<p>Returns random key.</p>","abstract":false,"args":[],"args_string":" : LinkType","args_html":" : LinkType","location":{"filename":"src/markov/transition_table.cr","line_number":89,"url":null},"def":{"name":"random_key","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"LinkType","visibility":"Public","body":"begin\n  (self.keys.sample(1)).first\nrescue IndexError\n  raise(Exceptions::EmptyTransitionTableException.new(method: \"random_key\", message: \"Use TransitionTable#add or TransitionTable#fill to populate the TransitionTable instance and try again.\"))\nend"}},{"id":"random_matrix:TransitionMatrix(LinkType)-instance-method","html_id":"random_matrix:TransitionMatrix(LinkType)-instance-method","name":"random_matrix","doc":"Returns random `TransitionMatrix` from table.","summary":"<p>Returns random <code><a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a></code> from table.</p>","abstract":false,"args":[],"args_string":" : TransitionMatrix(LinkType)","args_html":" : <a href=\"../Markov/TransitionMatrix.html\">TransitionMatrix</a>(LinkType)","location":{"filename":"src/markov/transition_table.cr","line_number":101,"url":null},"def":{"name":"random_matrix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"TransitionMatrix(LinkType)","visibility":"Public","body":"self[random_key]"}},{"id":"reset-instance-method","html_id":"reset-instance-method","name":"reset","doc":"tt.probable? after: \"gatsby\" #=> nil\ntt.probable? after: \"great\" #=> \"expectations\" or \"gatsby\"\n```","summary":"<p>tt.probable? after: \"gatsby\" #=> nil tt.probable? after: \"great\" #=> \"expectations\" or \"gatsby\" <code></code>`</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/markov/transition_table.cr","line_number":117,"url":null},"def":{"name":"reset","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@last_added_key = nil"}}],"macros":[],"types":[]}]}]}}